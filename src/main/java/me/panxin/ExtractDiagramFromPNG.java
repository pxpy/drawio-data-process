package me.panxin;import org.w3c.dom.Document;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import java.io.*;import java.net.URLDecoder;import java.util.AbstractMap;import java.util.HashMap;import java.util.Map;import java.util.zip.Inflater;import java.util.Base64;/** * 从png图片中提取drawio原始信息 * @author panxin * @date 2024/02/02 */public class ExtractDiagramFromPNG {    private static final byte[] PNG_HEAD = {(byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a};    private static final byte[] PNG_IEND = {0x49, 0x45, 0x4E, 0x44};    private static final byte[] PNG_ZTXT = {0x7A, 0x54, 0x58, 0x74};    private static final byte[] PNG_TEXT = {'t', 'E', 'X', 't'};    /**     * 根据文件流提取数据     * @param fis     * @return {@link String}     */    public static String extractData(FileInputStream fis) {        Map<String, byte[]> ztxt = new HashMap<>();        try {            if (!validPNG(fis)) {                System.err.println("Invalid PNG file");                System.exit(1);            }            while (true) {                Map.Entry<byte[], byte[]> section = readSection(fis);                byte[] sectype = section.getKey();                byte[] contents = section.getValue();                if (isEqual(sectype, PNG_IEND)) {                    break;                } else if (isEqual(sectype, PNG_ZTXT) || isEqual(sectype, PNG_TEXT)) {                    int idx = indexOf(contents, (byte) 0);                    if (idx != -1) {                        String keyname = new String(contents, 0, idx);                        byte[] data = new byte[contents.length - idx - 2];                        System.arraycopy(contents, idx + 2, data, 0, data.length);                        ztxt.put(keyname, data);                    }                }            }            byte[] mxfiles = ztxt.get("mxfile");            String s = new String(mxfiles);            String decodedString = URLDecoder.decode(s, "UTF-8");            String xmlString = extractSubstring(decodedString);            if(XMLUtil.hasChildren(xmlString)){                return XMLUtil.extractDiagramText(xmlString);            }else{                // 提取diagram文本                String mxfile = XMLUtil.extractDiagramText(xmlString);                String s1 = decompressAndDecode(mxfile);                return URLDecoder.decode(s1, "UTF-8");            }        } catch (IOException e) {            e.printStackTrace();            throw  new RuntimeException(e);        } catch (Exception e) {            throw new RuntimeException(e);        }    }    /**     * base64解码及解压缩     * @param base64EncodedString     * @return {@link String}     * @throws Exception     */    public static String decompressAndDecode(String base64EncodedString) throws Exception {        // 解码Base64字符串为字节数组        byte[] decodedBytes = Base64.getDecoder().decode(base64EncodedString);        String s = new String(decodedBytes,"UTF-8");        // 创建解压缩器        Inflater inflater = new Inflater(true);        inflater.setInput(decodedBytes);        // 创建一个足够大的缓冲区来存放解压缩后的数据        byte[] buffer = new byte[1024];        StringBuilder decompressedString = new StringBuilder();        // 解压缩数据        while (!inflater.finished()) {            int count = inflater.inflate(buffer);            decompressedString.append(new String(buffer, 0, count, "UTF-8"));        }        // 关闭解压缩器        inflater.end();        // 返回解压缩后的字符串        return decompressedString.toString();    }    /**     * 验证是否未png图片     * @param f     * @return boolean     * @throws IOException     */    private static boolean validPNG(FileInputStream f) throws IOException {        byte[] head = new byte[8];        int bytesRead = f.read(head);        return bytesRead == 8 && isEqual(head, PNG_HEAD);    }    private static Map.Entry<byte[], byte[]> readSection(FileInputStream f) throws IOException {        byte[] lengthBytes = new byte[4];        int bytesRead = f.read(lengthBytes);        if (bytesRead != 4) {            throw new IOException("Failed to read section length");        }        int length = (lengthBytes[0] << 24) | ((lengthBytes[1] & 0xFF) << 16) | ((lengthBytes[2] & 0xFF) << 8) | (lengthBytes[3] & 0xFF);        byte[] sectype = new byte[4];        bytesRead = f.read(sectype);        if (bytesRead != 4) {            throw new IOException("Failed to read section type");        }        byte[] contents = new byte[length];        bytesRead = f.read(contents);        if (bytesRead != length) {            throw new IOException("Failed to read section contents");        }        byte[] crc = new byte[4];        f.read(crc);        return new AbstractMap.SimpleEntry<>(sectype, contents);    }    private static boolean isEqual(byte[] a, byte[] b) {        if (a.length != b.length) {            return false;        }        for (int i = 0; i < a.length; i++) {            if (a[i] != b[i]) {                return false;            }        }        return true;    }    private static int indexOf(byte[] array, byte target) {        for (int i = 0; i < array.length; i++) {            if (array[i] == target) {                return i;            }        }        return -1;    }    private static String extractSubstring(String inputString) {        int startIdx = inputString.indexOf("<diagram");        int endIdx = inputString.indexOf("</diagram>") + "</diagram>".length();        if (startIdx != -1 && endIdx != -1) {            return inputString.substring(startIdx, endIdx);        } else {            return "未找到匹配的子字符串";        }    }}